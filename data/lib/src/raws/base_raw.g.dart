// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'base_raw.dart';

// **************************************************************************
// CopyWithGenerator
// **************************************************************************

abstract class _$TestRawCWProxy {
  TestRaw message(String message);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `TestRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// TestRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  TestRaw call({
    String? message,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfTestRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfTestRaw.copyWith.fieldName(...)`
class _$TestRawCWProxyImpl implements _$TestRawCWProxy {
  const _$TestRawCWProxyImpl(this._value);

  final TestRaw _value;

  @override
  TestRaw message(String message) => this(message: message);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `TestRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// TestRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  TestRaw call({
    Object? message = const $CopyWithPlaceholder(),
  }) {
    return TestRaw(
      message: message == const $CopyWithPlaceholder() || message == null
          ? _value.message
          // ignore: cast_nullable_to_non_nullable
          : message as String,
    );
  }
}

extension $TestRawCopyWith on TestRaw {
  /// Returns a callable class that can be used as follows: `instanceOfTestRaw.copyWith(...)` or like so:`instanceOfTestRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$TestRawCWProxy get copyWith => _$TestRawCWProxyImpl(this);
}

abstract class _$TokensRawCWProxy {
  TokensRaw accessToken(String accessToken);

  TokensRaw refreshToken(String refreshToken);

  TokensRaw idToken(String idToken);

  TokensRaw expiresIn(int expiresIn);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `TokensRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// TokensRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  TokensRaw call({
    String? accessToken,
    String? refreshToken,
    String? idToken,
    int? expiresIn,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfTokensRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfTokensRaw.copyWith.fieldName(...)`
class _$TokensRawCWProxyImpl implements _$TokensRawCWProxy {
  const _$TokensRawCWProxyImpl(this._value);

  final TokensRaw _value;

  @override
  TokensRaw accessToken(String accessToken) => this(accessToken: accessToken);

  @override
  TokensRaw refreshToken(String refreshToken) =>
      this(refreshToken: refreshToken);

  @override
  TokensRaw idToken(String idToken) => this(idToken: idToken);

  @override
  TokensRaw expiresIn(int expiresIn) => this(expiresIn: expiresIn);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `TokensRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// TokensRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  TokensRaw call({
    Object? accessToken = const $CopyWithPlaceholder(),
    Object? refreshToken = const $CopyWithPlaceholder(),
    Object? idToken = const $CopyWithPlaceholder(),
    Object? expiresIn = const $CopyWithPlaceholder(),
  }) {
    return TokensRaw(
      accessToken:
          accessToken == const $CopyWithPlaceholder() || accessToken == null
              ? _value.accessToken
              // ignore: cast_nullable_to_non_nullable
              : accessToken as String,
      refreshToken:
          refreshToken == const $CopyWithPlaceholder() || refreshToken == null
              ? _value.refreshToken
              // ignore: cast_nullable_to_non_nullable
              : refreshToken as String,
      idToken: idToken == const $CopyWithPlaceholder() || idToken == null
          ? _value.idToken
          // ignore: cast_nullable_to_non_nullable
          : idToken as String,
      expiresIn: expiresIn == const $CopyWithPlaceholder() || expiresIn == null
          ? _value.expiresIn
          // ignore: cast_nullable_to_non_nullable
          : expiresIn as int,
    );
  }
}

extension $TokensRawCopyWith on TokensRaw {
  /// Returns a callable class that can be used as follows: `instanceOfTokensRaw.copyWith(...)` or like so:`instanceOfTokensRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$TokensRawCWProxy get copyWith => _$TokensRawCWProxyImpl(this);
}

abstract class _$DocumentRawCWProxy {
  DocumentRaw content(String content);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `DocumentRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// DocumentRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  DocumentRaw call({
    String? content,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfDocumentRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfDocumentRaw.copyWith.fieldName(...)`
class _$DocumentRawCWProxyImpl implements _$DocumentRawCWProxy {
  const _$DocumentRawCWProxyImpl(this._value);

  final DocumentRaw _value;

  @override
  DocumentRaw content(String content) => this(content: content);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `DocumentRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// DocumentRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  DocumentRaw call({
    Object? content = const $CopyWithPlaceholder(),
  }) {
    return DocumentRaw(
      content: content == const $CopyWithPlaceholder() || content == null
          ? _value.content
          // ignore: cast_nullable_to_non_nullable
          : content as String,
    );
  }
}

extension $DocumentRawCopyWith on DocumentRaw {
  /// Returns a callable class that can be used as follows: `instanceOfDocumentRaw.copyWith(...)` or like so:`instanceOfDocumentRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$DocumentRawCWProxy get copyWith => _$DocumentRawCWProxyImpl(this);
}

abstract class _$StoreRawCWProxy {
  StoreRaw id(String? id);

  StoreRaw coverImage(String? coverImage);

  StoreRaw name(String? name);

  StoreRaw type(String? type);

  StoreRaw hasPromotion(bool? hasPromotion);

  StoreRaw isOpen(bool? isOpen);

  StoreRaw rating(double? rating);

  StoreRaw address(String? address);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `StoreRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// StoreRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  StoreRaw call({
    String? id,
    String? coverImage,
    String? name,
    String? type,
    bool? hasPromotion,
    bool? isOpen,
    double? rating,
    String? address,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfStoreRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfStoreRaw.copyWith.fieldName(...)`
class _$StoreRawCWProxyImpl implements _$StoreRawCWProxy {
  const _$StoreRawCWProxyImpl(this._value);

  final StoreRaw _value;

  @override
  StoreRaw id(String? id) => this(id: id);

  @override
  StoreRaw coverImage(String? coverImage) => this(coverImage: coverImage);

  @override
  StoreRaw name(String? name) => this(name: name);

  @override
  StoreRaw type(String? type) => this(type: type);

  @override
  StoreRaw hasPromotion(bool? hasPromotion) => this(hasPromotion: hasPromotion);

  @override
  StoreRaw isOpen(bool? isOpen) => this(isOpen: isOpen);

  @override
  StoreRaw rating(double? rating) => this(rating: rating);

  @override
  StoreRaw address(String? address) => this(address: address);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `StoreRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// StoreRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  StoreRaw call({
    Object? id = const $CopyWithPlaceholder(),
    Object? coverImage = const $CopyWithPlaceholder(),
    Object? name = const $CopyWithPlaceholder(),
    Object? type = const $CopyWithPlaceholder(),
    Object? hasPromotion = const $CopyWithPlaceholder(),
    Object? isOpen = const $CopyWithPlaceholder(),
    Object? rating = const $CopyWithPlaceholder(),
    Object? address = const $CopyWithPlaceholder(),
  }) {
    return StoreRaw(
      id: id == const $CopyWithPlaceholder()
          ? _value.id
          // ignore: cast_nullable_to_non_nullable
          : id as String?,
      coverImage: coverImage == const $CopyWithPlaceholder()
          ? _value.coverImage
          // ignore: cast_nullable_to_non_nullable
          : coverImage as String?,
      name: name == const $CopyWithPlaceholder()
          ? _value.name
          // ignore: cast_nullable_to_non_nullable
          : name as String?,
      type: type == const $CopyWithPlaceholder()
          ? _value.type
          // ignore: cast_nullable_to_non_nullable
          : type as String?,
      hasPromotion: hasPromotion == const $CopyWithPlaceholder()
          ? _value.hasPromotion
          // ignore: cast_nullable_to_non_nullable
          : hasPromotion as bool?,
      isOpen: isOpen == const $CopyWithPlaceholder()
          ? _value.isOpen
          // ignore: cast_nullable_to_non_nullable
          : isOpen as bool?,
      rating: rating == const $CopyWithPlaceholder()
          ? _value.rating
          // ignore: cast_nullable_to_non_nullable
          : rating as double?,
      address: address == const $CopyWithPlaceholder()
          ? _value.address
          // ignore: cast_nullable_to_non_nullable
          : address as String?,
    );
  }
}

extension $StoreRawCopyWith on StoreRaw {
  /// Returns a callable class that can be used as follows: `instanceOfStoreRaw.copyWith(...)` or like so:`instanceOfStoreRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$StoreRawCWProxy get copyWith => _$StoreRawCWProxyImpl(this);
}

abstract class _$ProductRawCWProxy {
  ProductRaw id(String? id);

  ProductRaw name(String? name);

  ProductRaw description(String? description);

  ProductRaw coverImage(String? coverImage);

  ProductRaw price(int? price);

  ProductRaw categories(List<String>? categories);

  ProductRaw tags(List<String>? tags);

  ProductRaw isSoldOut(bool? isSoldOut);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `ProductRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// ProductRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  ProductRaw call({
    String? id,
    String? name,
    String? description,
    String? coverImage,
    int? price,
    List<String>? categories,
    List<String>? tags,
    bool? isSoldOut,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfProductRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfProductRaw.copyWith.fieldName(...)`
class _$ProductRawCWProxyImpl implements _$ProductRawCWProxy {
  const _$ProductRawCWProxyImpl(this._value);

  final ProductRaw _value;

  @override
  ProductRaw id(String? id) => this(id: id);

  @override
  ProductRaw name(String? name) => this(name: name);

  @override
  ProductRaw description(String? description) => this(description: description);

  @override
  ProductRaw coverImage(String? coverImage) => this(coverImage: coverImage);

  @override
  ProductRaw price(int? price) => this(price: price);

  @override
  ProductRaw categories(List<String>? categories) =>
      this(categories: categories);

  @override
  ProductRaw tags(List<String>? tags) => this(tags: tags);

  @override
  ProductRaw isSoldOut(bool? isSoldOut) => this(isSoldOut: isSoldOut);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `ProductRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// ProductRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  ProductRaw call({
    Object? id = const $CopyWithPlaceholder(),
    Object? name = const $CopyWithPlaceholder(),
    Object? description = const $CopyWithPlaceholder(),
    Object? coverImage = const $CopyWithPlaceholder(),
    Object? price = const $CopyWithPlaceholder(),
    Object? categories = const $CopyWithPlaceholder(),
    Object? tags = const $CopyWithPlaceholder(),
    Object? isSoldOut = const $CopyWithPlaceholder(),
  }) {
    return ProductRaw(
      id: id == const $CopyWithPlaceholder()
          ? _value.id
          // ignore: cast_nullable_to_non_nullable
          : id as String?,
      name: name == const $CopyWithPlaceholder()
          ? _value.name
          // ignore: cast_nullable_to_non_nullable
          : name as String?,
      description: description == const $CopyWithPlaceholder()
          ? _value.description
          // ignore: cast_nullable_to_non_nullable
          : description as String?,
      coverImage: coverImage == const $CopyWithPlaceholder()
          ? _value.coverImage
          // ignore: cast_nullable_to_non_nullable
          : coverImage as String?,
      price: price == const $CopyWithPlaceholder()
          ? _value.price
          // ignore: cast_nullable_to_non_nullable
          : price as int?,
      categories: categories == const $CopyWithPlaceholder()
          ? _value.categories
          // ignore: cast_nullable_to_non_nullable
          : categories as List<String>?,
      tags: tags == const $CopyWithPlaceholder()
          ? _value.tags
          // ignore: cast_nullable_to_non_nullable
          : tags as List<String>?,
      isSoldOut: isSoldOut == const $CopyWithPlaceholder()
          ? _value.isSoldOut
          // ignore: cast_nullable_to_non_nullable
          : isSoldOut as bool?,
    );
  }
}

extension $ProductRawCopyWith on ProductRaw {
  /// Returns a callable class that can be used as follows: `instanceOfProductRaw.copyWith(...)` or like so:`instanceOfProductRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$ProductRawCWProxy get copyWith => _$ProductRawCWProxyImpl(this);
}

abstract class _$MenuSectionRawCWProxy {
  MenuSectionRaw name(String name);

  MenuSectionRaw order(int order);

  MenuSectionRaw products(List<ProductRaw> products);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `MenuSectionRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// MenuSectionRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  MenuSectionRaw call({
    String? name,
    int? order,
    List<ProductRaw>? products,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfMenuSectionRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfMenuSectionRaw.copyWith.fieldName(...)`
class _$MenuSectionRawCWProxyImpl implements _$MenuSectionRawCWProxy {
  const _$MenuSectionRawCWProxyImpl(this._value);

  final MenuSectionRaw _value;

  @override
  MenuSectionRaw name(String name) => this(name: name);

  @override
  MenuSectionRaw order(int order) => this(order: order);

  @override
  MenuSectionRaw products(List<ProductRaw> products) =>
      this(products: products);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `MenuSectionRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// MenuSectionRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  MenuSectionRaw call({
    Object? name = const $CopyWithPlaceholder(),
    Object? order = const $CopyWithPlaceholder(),
    Object? products = const $CopyWithPlaceholder(),
  }) {
    return MenuSectionRaw(
      name: name == const $CopyWithPlaceholder() || name == null
          ? _value.name
          // ignore: cast_nullable_to_non_nullable
          : name as String,
      order: order == const $CopyWithPlaceholder() || order == null
          ? _value.order
          // ignore: cast_nullable_to_non_nullable
          : order as int,
      products: products == const $CopyWithPlaceholder() || products == null
          ? _value.products
          // ignore: cast_nullable_to_non_nullable
          : products as List<ProductRaw>,
    );
  }
}

extension $MenuSectionRawCopyWith on MenuSectionRaw {
  /// Returns a callable class that can be used as follows: `instanceOfMenuSectionRaw.copyWith(...)` or like so:`instanceOfMenuSectionRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$MenuSectionRawCWProxy get copyWith => _$MenuSectionRawCWProxyImpl(this);
}

abstract class _$MenuRawCWProxy {
  MenuRaw id(String id);

  MenuRaw menuSections(List<MenuSectionRaw> menuSections);

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `MenuRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// MenuRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  MenuRaw call({
    String? id,
    List<MenuSectionRaw>? menuSections,
  });
}

/// Proxy class for `copyWith` functionality. This is a callable class and can be used as follows: `instanceOfMenuRaw.copyWith(...)`. Additionally contains functions for specific fields e.g. `instanceOfMenuRaw.copyWith.fieldName(...)`
class _$MenuRawCWProxyImpl implements _$MenuRawCWProxy {
  const _$MenuRawCWProxyImpl(this._value);

  final MenuRaw _value;

  @override
  MenuRaw id(String id) => this(id: id);

  @override
  MenuRaw menuSections(List<MenuSectionRaw> menuSections) =>
      this(menuSections: menuSections);

  @override

  /// This function **does support** nullification of nullable fields. All `null` values passed to `non-nullable` fields will be ignored. You can also use `MenuRaw(...).copyWith.fieldName(...)` to override fields one at a time with nullification support.
  ///
  /// Usage
  /// ```dart
  /// MenuRaw(...).copyWith(id: 12, name: "My name")
  /// ````
  MenuRaw call({
    Object? id = const $CopyWithPlaceholder(),
    Object? menuSections = const $CopyWithPlaceholder(),
  }) {
    return MenuRaw(
      id: id == const $CopyWithPlaceholder() || id == null
          ? _value.id
          // ignore: cast_nullable_to_non_nullable
          : id as String,
      menuSections:
          menuSections == const $CopyWithPlaceholder() || menuSections == null
              ? _value.menuSections
              // ignore: cast_nullable_to_non_nullable
              : menuSections as List<MenuSectionRaw>,
    );
  }
}

extension $MenuRawCopyWith on MenuRaw {
  /// Returns a callable class that can be used as follows: `instanceOfMenuRaw.copyWith(...)` or like so:`instanceOfMenuRaw.copyWith.fieldName(...)`.
  // ignore: library_private_types_in_public_api
  _$MenuRawCWProxy get copyWith => _$MenuRawCWProxyImpl(this);
}

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

TestRaw _$TestRawFromJson(Map<String, dynamic> json) => TestRaw(
      message: json['message'] as String,
    );

Map<String, dynamic> _$TestRawToJson(TestRaw instance) => <String, dynamic>{
      'message': instance.message,
    };

TokensRaw _$TokensRawFromJson(Map<String, dynamic> json) => TokensRaw(
      accessToken: json['accessToken'] as String,
      refreshToken: json['refreshToken'] as String,
      idToken: json['idToken'] as String,
      expiresIn: json['expiresIn'] as int,
    );

Map<String, dynamic> _$TokensRawToJson(TokensRaw instance) => <String, dynamic>{
      'accessToken': instance.accessToken,
      'refreshToken': instance.refreshToken,
      'idToken': instance.idToken,
      'expiresIn': instance.expiresIn,
    };

DocumentRaw _$DocumentRawFromJson(Map<String, dynamic> json) => DocumentRaw(
      content: json['content'] as String,
    );

Map<String, dynamic> _$DocumentRawToJson(DocumentRaw instance) =>
    <String, dynamic>{
      'content': instance.content,
    };

StoreRaw _$StoreRawFromJson(Map<String, dynamic> json) => StoreRaw(
      id: json['id'] as String?,
      coverImage: json['coverImage'] as String?,
      name: json['name'] as String?,
      type: json['type'] as String?,
      hasPromotion: json['hasPromotion'] as bool?,
      isOpen: json['isOpen'] as bool?,
      rating: (json['rating'] as num?)?.toDouble(),
      address: json['address'] as String?,
    );

Map<String, dynamic> _$StoreRawToJson(StoreRaw instance) => <String, dynamic>{
      'id': instance.id,
      'coverImage': instance.coverImage,
      'name': instance.name,
      'type': instance.type,
      'hasPromotion': instance.hasPromotion,
      'isOpen': instance.isOpen,
      'rating': instance.rating,
      'address': instance.address,
    };

ProductRaw _$ProductRawFromJson(Map<String, dynamic> json) => ProductRaw(
      id: json['id'] as String?,
      name: json['name'] as String?,
      description: json['description'] as String?,
      coverImage: json['coverImage'] as String?,
      price: json['price'] as int?,
      categories: (json['categories'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      tags: (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList(),
      isSoldOut: json['isSoldOut'] as bool?,
    );

Map<String, dynamic> _$ProductRawToJson(ProductRaw instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'description': instance.description,
      'coverImage': instance.coverImage,
      'price': instance.price,
      'categories': instance.categories,
      'tags': instance.tags,
      'isSoldOut': instance.isSoldOut,
    };

MenuSectionRaw _$MenuSectionRawFromJson(Map<String, dynamic> json) =>
    MenuSectionRaw(
      name: json['name'] as String,
      order: json['order'] as int,
      products: (json['products'] as List<dynamic>)
          .map((e) => ProductRaw.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$MenuSectionRawToJson(MenuSectionRaw instance) =>
    <String, dynamic>{
      'name': instance.name,
      'order': instance.order,
      'products': instance.products,
    };

MenuRaw _$MenuRawFromJson(Map<String, dynamic> json) => MenuRaw(
      id: json['id'] as String,
      menuSections: (json['menuSections'] as List<dynamic>)
          .map((e) => MenuSectionRaw.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$MenuRawToJson(MenuRaw instance) => <String, dynamic>{
      'id': instance.id,
      'menuSections': instance.menuSections,
    };
